/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2017 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package ti.explorer;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URISyntaxException;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.TiConfig;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.TiFileProxy;
import org.appcelerator.titanium.io.TiBaseFile;
import org.appcelerator.titanium.io.TiFileFactory;
import org.appcelerator.titanium.util.TiActivityResultHandler;
import org.appcelerator.titanium.util.TiActivitySupport;

import android.Manifest;
import android.app.Activity;
import android.content.ContentUris;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.database.DatabaseUtils;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.provider.DocumentsContract;
import android.provider.MediaStore;
import android.provider.OpenableColumns;
import android.support.v4.app.ActivityCompat;
import android.support.v4.content.ContextCompat;
import android.util.Log;


@Kroll.module(name="Tiexplorer", id="ti.explorer")
public class TiexplorerModule extends KrollModule
{

	// Standard Debugging variables
	private static final String LCAT = "TiexplorerModule";
	private static final boolean DBG = TiConfig.LOGD;
	
	// Constants
	@Kroll.constant
	public static final int RESULT_OK = -1;
	@Kroll.constant
	public static final int RESULT_CANCELED = 0;
	@Kroll.constant
	public static final int RESULT_ERROR = 1;
	
	private static final int REQUEST_FILE_PICK = 2;
	private static final int REQUEST_PERMISSION = 201;
	
	/**
	 * Context to Access resources
	 */
	private static Context ctx;
	
	private Uri mFileUri;
	
	/**
	 * MIME Type to Access type of File
	 * Default type is *\/* Used 
	 */
	private String mimeType = "*/*";
	
	/**
	 * Result Callback function to return File Object
	 */
	private KrollFunction successCallback;
	private KrollFunction errorCallback;
	
	@Kroll.constant
	public static final int EXTERNAL_STORAGE = 1;
	
	@Kroll.constant
	public static final int CACHE_DIRECTORY = 2;
	
	@Kroll.constant
	public static final int DATA_DIRECTORY = 3;
	
	@Kroll.constant
	public static final int EXTERNAL_CACHE_DIRECTORY = 4;
	
	private int DIRECTORY = CACHE_DIRECTORY;
	
	private static final String READ_PERMISSION = Manifest.permission.READ_EXTERNAL_STORAGE;
	private static final String WRITE_PERMISSION = Manifest.permission.WRITE_EXTERNAL_STORAGE;

	private String[] requestedPermission = new String[]{ READ_PERMISSION, WRITE_PERMISSION};

	public TiexplorerModule()
	{
		super();
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app)
	{
		// Get Application Context
		ctx = TiApplication.getInstance().getApplicationContext();
	}
	
	/**
	 * Select File from Explorer and then make process on it.
	 */
	@Kroll.method
	public void selectFile(KrollDict params) throws Exception {
		if(init(params)) {
			// Check Permission
			if(ContextCompat.checkSelfPermission(ctx, READ_PERMISSION) != PackageManager.PERMISSION_GRANTED &&
					ContextCompat.checkSelfPermission(ctx, WRITE_PERMISSION) != PackageManager.PERMISSION_GRANTED) {
				ActivityCompat.requestPermissions(getActivity(), requestedPermission, REQUEST_PERMISSION);
				throwError(RESULT_ERROR, "Please give access to read/write permissions.");
				return;
			}
			
			// Start Explicit Intent
			TiActivitySupport activity = (TiActivitySupport) TiApplication.getInstance()
											.getCurrentActivity();
			activity.launchActivityForResult(Intent.createChooser(getIntent(), "Please select file!"), REQUEST_FILE_PICK, getActivityHandler());
		} else {
			throwError(RESULT_CANCELED, "Please include onSuccess/onError methods.");
		}
	}
	
	/**
	 * Validate KrollDict type parameters and set default if no value
	 * @param params
	 * @return Success or Error
	 */
	private boolean init(KrollDict params) {
		Boolean isSuccess = true;
		
		// Set MIME Type if available else use default.
		if(params.containsKeyAndNotNull("mimeType")) {
			this.setMimeType(params.getString("mimeType")); 
		} else {
			this.setMimeType("*/*");
		}
		
		// Set storageDirectory if available else use CACHE_DIRECTORY.
		if(params.containsKeyAndNotNull("location")) {
			this.setFileLocation(params.getInt("location"));
		} else {
			this.setFileLocation(CACHE_DIRECTORY);
		}
		
		// Set Success Callback functions 
		if(params.containsKeyAndNotNull("onSuccess")) {
			this.setSuccessCallback(params.get("onSuccess"));
		} else {
			isSuccess = false;
		}
		
		// Set Error Callback functions
		if(params.containsKeyAndNotNull("onError")) {
			this.setErrorCallback(params.get("onError"));
		} else {
			isSuccess = false;
		}
		
		return isSuccess;
	}
	
	/**
	 * Handle the Result Handler to Pick File from Internal/External Storage
	 * @return TiActivityResultHandler
	 */
	private TiActivityResultHandler getActivityHandler() {
		return new TiActivityResultHandler() {

			public void onError(Activity activity, int resultCode, Exception exception) {
				throwError(RESULT_ERROR, "Error opening activity for result");
			}

			public void onResult(Activity activity, int requestCode, int resultCode, Intent data) {
				if(requestCode == REQUEST_FILE_PICK) {
					if(resultCode == RESULT_OK) {
						mFileUri = data.getData();
						String filename = "";
						String mimeType = activity.getContentResolver().getType(mFileUri);

						if (mimeType == null) {
							String path = getPath(ctx, mFileUri);
		                    if (path == null) {
		                    	filename = getFilename();
		                    } else {
		                    	File file = new File(path);
		                    	filename = file.getName();
		                    }
		                } else {
		                    Uri returnUri = data.getData();
		                    Cursor returnCursor = ctx.getContentResolver().query(returnUri, null, null, null, null);
		                    int nameIndex = returnCursor.getColumnIndex(OpenableColumns.DISPLAY_NAME);
		                    int sizeIndex = returnCursor.getColumnIndex(OpenableColumns.SIZE);
		                    returnCursor.moveToFirst();
		                    filename = returnCursor.getString(nameIndex);
		                    String size = Long.toString(returnCursor.getLong(sizeIndex));
		                }
							
						File directory = getLocationDirectory();
						String sourcePath = directory.toString();
						try {
							String fpath = sourcePath + File.separator + filename;
							TiFileProxy fileProxy = createTiFileProxy(fpath);
							if(fileProxy.exists()) {
								KrollDict successDict = new KrollDict();
								
								String filePath = fileProxy.getNativePath();
								successDict.put("status", RESULT_OK);
								successDict.put("file", fileProxy);
								successDict.put("path", filePath);
								successDict.put("message", "Successfully captured file!");
								successCallback.call(getKrollObject(), successDict);
							} else {
								throwError(RESULT_ERROR, "Unable to read selected file");
							}
						} catch (Exception e) {
							e.printStackTrace();
							throwError(RESULT_ERROR, "Exception occured to read selected file");
						}
					} else if(resultCode == RESULT_CANCELED) {
						throwError(RESULT_CANCELED, "Action Canceled by user");
					}
				} // REQUEST CODE Completed
			} // onResult Completed
		}; // return Statement Completed
	}
	
	private TiFileProxy createTiFileProxy(String path) throws FileNotFoundException {
		return new TiFileProxy(createBaseFileProxy(path));
	}
	
	private TiBaseFile createBaseFileProxy(String path) throws FileNotFoundException {
		TiBaseFile tiFile = null;
		if(path != null) {
			try {
				tiFile = copyFileStream(new File(path), mFileUri, ctx);
			} catch (Exception e) {
				throw new FileNotFoundException();
			}
		} else {
			throwError(RESULT_ERROR, "File not found on location!");
		}
		
		return tiFile;
	}
	
	private TiBaseFile copyFileStream(File dest, Uri uri, Context context)
	        throws IOException {
	    InputStream is = null;
	    OutputStream os = null;
	    try {
	        is = context.getContentResolver().openInputStream(uri);
	        os = new FileOutputStream(dest);
	        byte[] buffer = new byte[1024];
	        int length;

	        while ((length = is.read(buffer)) > 0) {
	            os.write(buffer, 0, length);

	        }
	        if(dest.exists()) {
	        	return TiFileFactory.createTitaniumFile(dest.getAbsolutePath(), false);
	        }
	    } catch (Exception e) {
	        e.printStackTrace();
	        return null;
	    } finally {
	        is.close();
	        os.close();
	    }
	    return null;
	}
	
	private String getFilename() {
		String fileName = null;
		String[] projection = {MediaStore.MediaColumns.DISPLAY_NAME};
		
		Cursor cursor = ctx.getContentResolver().query(mFileUri, projection, null, null, null);
		if(cursor != null) {
			try {
				if(cursor.moveToFirst()) {
					fileName = cursor.getString(0);
				}
			} finally {
				cursor.close();
			}
		}
		return fileName;
	}
	
	/**
	 * Throw the error on onError Callback function
	 */
	private void throwError(int status, String message) {
		KrollDict errorDict = new KrollDict();
		errorDict.put("status", status);
		errorDict.put("message", message);
		this.errorCallback.call(getKrollObject(), errorDict);
	}

	/**
	 * Create Intent to Open File Chooser Intent
	 * @return Intent
	 */
	private Intent getIntent() {
		Intent intent = new Intent();
		intent.setAction(Intent.ACTION_GET_CONTENT);
		intent.setType(getMimeType());
		intent.addCategory(Intent.CATEGORY_OPENABLE);
		return intent;
	}
	
	private void setFileLocation(int location) {
		this.DIRECTORY = location;
	}
	
	private int getFileLocation() {
		return this.DIRECTORY;
	}

	private void setErrorCallback(Object response) {
		this.errorCallback = (KrollFunction) response;
	}

	private void setSuccessCallback(Object response) {
		this.successCallback = (KrollFunction) response;
	}

	
	private void setMimeType(String type) {
		this.mimeType = type;
	}
	private String getMimeType() {
		return this.mimeType;
	}
	
	protected File getLocationDirectory() {
		File locationDirectory = null;
		int dir = this.getFileLocation();
		
		switch(dir) {
		case EXTERNAL_STORAGE:
			locationDirectory = getExternalStorage();
			break;
		case EXTERNAL_CACHE_DIRECTORY:
			locationDirectory = getExternalCacheStorage();
			break;
		case CACHE_DIRECTORY:
			locationDirectory = getCacheDirectory();
			break;
		case DATA_DIRECTORY:
			locationDirectory = getDataDirectory();
			break;
		}
		
		return locationDirectory;
	}

	protected File getDataDirectory(){
		return ctx.getFilesDir();
	}
	
	private File getExternalCacheStorage() {
		File directory = getCacheDirectory();

		if (isExternalStorageWritable()) {
			directory = ctx.getExternalCacheDir();
		}

		return directory;
	}
	
	protected File getCacheDirectory(){
		return ctx.getCacheDir();
	}

	private File getExternalStorage() {
		File directory = ctx.getFilesDir();
		if(isExternalStorageWritable()) {
			directory = ctx.getExternalFilesDir(null);
		}
		
		return directory;
	}
	
	private boolean isExternalStorageWritable() {

		Boolean isWritable = false;
		String state = Environment.getExternalStorageState();

		if (Environment.MEDIA_MOUNTED.equals(state)) {
			isWritable = true;
		}

		return isWritable;
	}
	
	public static String getPath(Context context, Uri uri) {
	    final boolean isKitKat = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;

	    // DocumentProvider
	    if (isKitKat && DocumentsContract.isDocumentUri(context, uri)) {
	        // ExternalStorageProvider
	        if (isExternalStorageDocument(uri)) {
	            final String docId = DocumentsContract.getDocumentId(uri);
	            final String[] split = docId.split(":");
	            final String type = split[0];

	            if ("primary".equalsIgnoreCase(type)) {
	                return Environment.getExternalStorageDirectory() + "/" + split[1];
	            }
	            // TODO handle non-primary volumes
	        }
	        // DownloadsProvider
	        else if (isDownloadsDocument(uri)) {
	            final String id = DocumentsContract.getDocumentId(uri);
	            final Uri contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), Long.valueOf(id));
	            return getDataColumn(context, contentUri, null, null);
	        }
	        // MediaProvider
	        else
	        if (isMediaDocument(uri)) {
	            final String docId = DocumentsContract.getDocumentId(uri);
	            final String[] split = docId.split(":");
	            final String type = split[0];
	            Uri contentUri = null;
	            if ("image".equals(type)) {
	                contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
	            } else if ("video".equals(type)) {
	                contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
	            } else if ("audio".equals(type)) {
	                contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
	            }
	            final String selection = "_id=?";
	            final String[] selectionArgs = new String[] {split[1]};
	            return getDataColumn(context, contentUri, selection, selectionArgs);
	        }
	    }
	    // MediaStore (and general)
	    else if ("content".equalsIgnoreCase(uri.getScheme())) {
	        // Return the remote address
	        if (isGooglePhotosUri(uri))
	            return uri.getLastPathSegment();
	        return getDataColumn(context, uri, null, null);
	    }
	    // File
	    else if ("file".equalsIgnoreCase(uri.getScheme())) {
	        return uri.getPath();
	    }
	    return null;
	}

	public static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) {
	    Cursor cursor = null;
	    final String column = "_data";
	    final String[] projection = { column };
	    try {
	        cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null);
	        if (cursor != null && cursor.moveToFirst()) {
	            final int index = cursor.getColumnIndexOrThrow(column);
	            return cursor.getString(index);
	        }
	    } finally {
	        if (cursor != null)
	            cursor.close();
	    }
	    return null;
	}

	public static boolean isExternalStorageDocument(Uri uri) {
	    return "com.android.externalstorage.documents".equals(uri.getAuthority());
	}

	/**
	 * @param uri The Uri to check.
	 * @return Whether the Uri authority is DownloadsProvider.
	 */
	public static boolean isDownloadsDocument(Uri uri) {
	    return "com.android.providers.downloads.documents".equals(uri.getAuthority());
	}

	/**
	 * @param uri The Uri to check.
	 * @return Whether the Uri authority is MediaProvider.
	 */
	public static boolean isMediaDocument(Uri uri) {
	    return "com.android.providers.media.documents".equals(uri.getAuthority());
	}

	/**
	 * @param uri The Uri to check.
	 * @return Whether the Uri authority is Google Photos.
	 */
	public static boolean isGooglePhotosUri(Uri uri) {
	    return "com.google.android.apps.photos.content".equals(uri.getAuthority());
	}
}

